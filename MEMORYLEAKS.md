# Утечки памяти и их исправления

В этом документе описаны утечки памяти, найденные в проекте, и способы их исправления.

## 1. Утечка памяти в GameEngine.ts - requestAnimationFrame

### Проблема

В классе `GameEngine` метод `requestAnimationFrame` продолжал вызываться даже после вызова `stop()` или `destroy()`, так как не было отмены запланированных кадров анимации. Это приводило к:

- Постоянному выполнению игрового цикла даже после остановки игры
- Утечке памяти из-за незавершенных запросов анимации
- Нагрузке на процессор при отсутствии видимого результата

### Причина

При вызове `requestAnimationFrame(this.loop)` возвращается идентификатор кадра, который необходимо сохранить и использовать для отмены через `cancelAnimationFrame()`. В коде этот идентификатор не сохранялся, поэтому отменить запланированный кадр было невозможно.

### Решение

1. Добавлено поле `animationFrameId: number | null = null` для хранения идентификатора текущего кадра анимации
2. В методе `start()` сохраняется идентификатор: `this.animationFrameId = requestAnimationFrame(this.loop)`
3. В методе `stop()` добавлена отмена запланированного кадра:
   ```typescript
   if (this.animationFrameId !== null) {
     cancelAnimationFrame(this.animationFrameId)
     this.animationFrameId = null
   }
   ```
4. В методе `destroy()` вызывается `stop()` для гарантированной очистки
5. В методе `loop()` идентификатор сохраняется после каждого нового запроса анимации

### Файлы

- `packages/client/src/engine/core/GameEngine.ts`

---

## 2. Утечка памяти в Error404Page.tsx - setTimeout

### Проблема

В компоненте `Error404Page` при клике на зомби создавался `setTimeout` для перенаправления на главную страницу через 1 секунду. Если компонент размонтировался до завершения таймера (например, пользователь ушел со страницы), таймер продолжал работать и пытался вызвать `navigate()` на уже размонтированном компоненте. Это приводило к:

- Потенциальным ошибкам при попытке навигации на несуществующем компоненте
- Утечке памяти из-за незавершенного таймера
- Некорректному поведению приложения

### Причина

Таймер создавался, но его идентификатор не сохранялся, поэтому не было возможности очистить его при размонтировании компонента.

### Решение

1. Добавлен `useRef` для хранения идентификатора таймера: `const timeoutRef = useRef<NodeJS.Timeout | null>(null)`
2. При создании таймера сохраняется идентификатор: `timeoutRef.current = setTimeout(...)`
3. Добавлен `useEffect` с cleanup-функцией для очистки таймера при размонтировании:
   ```typescript
   useEffect(() => {
     return () => {
       if (timeoutRef.current) {
         clearTimeout(timeoutRef.current)
         timeoutRef.current = null
       }
     }
   }, [])
   ```

### Файлы

- `packages/client/src/pages/Error404Page/Error404Page.tsx`

---

## 3. Утечка памяти в GameMenuPage.tsx - setInterval

### Проблема

В компоненте `GameMenuPage` при вызове функции `startGame()` создавался `setInterval` для обратного отсчета. Если пользователь несколько раз нажимал кнопку "Begin Mission" подряд, создавались несколько одновременно работающих интервалов, так как предыдущий интервал не очищался перед созданием нового. Это приводило к:

- Множественным одновременно работающим таймерам
- Быстрому изменению состояния `countdown` из-за нескольких параллельных обновлений
- Утечке памяти из-за накопления интервалов
- Некорректному поведению обратного отсчета

### Причина

Перед созданием нового интервала не проверялось наличие и не очищался существующий интервал.

### Решение

В функции `startGame()` добавлена проверка и очистка предыдущего интервала перед созданием нового:

```typescript
const startGame = () => {
  // Очищаем предыдущий интервал, если он существует, чтобы избежать утечки памяти
  if (intervalRef.current) {
    clearInterval(intervalRef.current);
    intervalRef.current = null;
  }
  setCountdown(GAME_CONFIG.COUNTDOWN_DURATION);
  intervalRef.current = setInterval(...);
};
```

### Файлы

- `packages/client/src/pages/GameMenuPage/GameMenuPage.tsx`

---

## 4. Утечка памяти в GameCanvas.tsx - обработчик события EventBus

### Проблема

В компоненте `GameCanvas` при создании игрового движка обработчик события `playerKilled` добавлялся в EventBus как анонимная функция:

```typescript
engine.eventBus.on('playerKilled', () => {
  logger.debug('Event bus: playerKilled event received')
  handlePlayerKilled()
})
```

При очистке движка в `handleCleanupEngine()` пыталась удалиться другая функция (`handlePlayerKilled`):

```typescript
engine.eventBus.off('playerKilled', handlePlayerKilled)
```

Так как это были разные функции, обработчик не удалялся из EventBus, что приводило к:

- Накоплению обработчиков событий при перезапуске игры
- Утечке памяти из-за незавершенных подписок на события
- Некорректному поведению при многократном создании/уничтожении игрового движка
- Вызову обработчиков на уже уничтоженных объектах

### Причина

Анонимная функция и функция из callback не являются одной и той же ссылкой в JavaScript, поэтому `off()` не мог найти и удалить правильный обработчик.

### Решение

1. Добавлен `useRef` для хранения ссылки на обработчик события: `const playerKilledHandlerRef = useRef<(() => void) | null>(null)`
2. При создании обработчика ссылка сохраняется:
   ```typescript
   const playerKilledHandler = () => {
     logger.debug('Event bus: playerKilled event received')
     handlePlayerKilled()
   }
   playerKilledHandlerRef.current = playerKilledHandler
   engine.eventBus.on('playerKilled', playerKilledHandler)
   ```
3. При очистке удаляется именно тот обработчик, который был добавлен:
   ```typescript
   if (engine && playerKilledHandlerRef.current) {
     engine.eventBus.off('playerKilled', playerKilledHandlerRef.current)
     playerKilledHandlerRef.current = null
   }
   ```

### Файлы

- `packages/client/src/components/GameCanvas/GameCanvas.tsx`

---

## Общие принципы предотвращения утечек памяти

### 1. Таймеры (setTimeout, setInterval)

- Всегда сохраняйте идентификатор таймера в `useRef` или переменной класса
- Очищайте таймеры в cleanup-функциях `useEffect` или методах `destroy()`
- Очищайте предыдущий таймер перед созданием нового, если это необходимо

### 2. requestAnimationFrame

- Сохраняйте идентификатор кадра анимации
- Отменяйте запланированные кадры через `cancelAnimationFrame()` при остановке
- Проверяйте состояние перед планированием нового кадра

### 3. Обработчики событий

- Сохраняйте ссылки на обработчики событий, чтобы можно было их удалить
- Используйте именованные функции или сохраняйте ссылки на анонимные функции
- Всегда удаляйте обработчики в cleanup-функциях или методах уничтожения
- Удаляйте обработчики на тех же элементах, на которых они были добавлены

### 4. Подписки и EventBus

- Сохраняйте ссылки на функции-обработчики, добавленные в системы подписок
- Удаляйте подписки при размонтировании компонентов
- Убедитесь, что функция, используемая для удаления, та же самая, что была добавлена

### 5. React хуки

- Используйте cleanup-функции в `useEffect` для всех побочных эффектов
- Очищайте все созданные ресурсы в cleanup-функции
- Учитывайте зависимости массивов в `useEffect`, чтобы избежать ненужных перезапусков

---

## Заключение

Все найденные утечки памяти были исправлены с соблюдением лучших практик React и JavaScript. Проект теперь корректно очищает все созданные ресурсы при размонтировании компонентов и остановке игрового движка, что предотвращает утечки памяти и обеспечивает стабильную работу приложения.
